扩大福内存池
==========

姑且命名为扩大福内存池  
扩大福内存池是一个轻量级且比较高效的定长内存池  
只有3个头文件, 把头文件带到你的项目中引用就可以使用  
其中一个头文件为分配器对象  
一个为定长内存池对象  
一个为变长内存池对象  


扩大福内存池仅使用几个基础API来支持这些功能  
定长内存池提供以下方法  
对应的文件 `CMemoryObjectPool.h`  

* Release 释放内存池
* clear 清空已分配内存, 不释放内存
* init 初始化内存池
* malloc 分配一个成员, 分配失败抛出 `std::bad_alloc()` 异常
* malloc_arr 分配一个数组, 分配失败抛出 `std::bad_alloc()` 异常
* realloc_arr 重定义数组成员数, 传递是地址不是内存池分配出去的地址抛出 `std::exception()` 异常
* free_arr 释放数组, 传递是地址不是内存池分配出去的地址抛出 `std::exception()` 异常
* free 释放一个成员, 传递是地址不是内存池分配出去的地址抛出 `std::exception()` 异常
* query 查询指定地址是否是内存池里分配出去的地址
* dump 输出当前内存池状态


变长内存池对应的文件 `CMemoryPool.h`
目前暂未实现

分配器对应文件 `CMemoryAllocator.h`
目前暂未使用, 想法是分配可执行属性的内存来使用  
或者就让用户自行实现分配器, 或者就使用默认的  

## 等待确定的事项
* 回收内存后当前操作的内存块是否改变
* 分配内存时是否遍历回收链表, `如果遍历内存会充分的重用, 但是影响效率`, `不遍历分配速度快但是可能有可用的内存没有分配出去`
* 每次增加内存块如何分配尺寸, 目前是增加一倍原来的成员数, 感觉这种方式不行
* 分配内存时优先从哪分配, 目前是从item开始分配, 可用考虑改成 `如果链表首节点的成员数和分配的成员数一样, 就从链表分配`, 就是会影响一些效率
* 64位下怎么处理节点指针的问题, 目前这样的处理方式是64位下每个节点必须最少占用8字节
* 

## 想实现暂未实现的功能
* 支持线程安全
* 作用域, 一个开始一个结束作用域的方法, 退出作用域后就回收作用域内分配的内存
* debug模式下检测越界之类的
* 其他等补充

## 作者
扩大福内存池目前由[扩大福](https://github.com/kuodafu/)设计和实现, 希望有更多志同道合的朋友加入  

## 开源协议
本代码使用MIT开源协议  
* 允许任何人以任何方式使用
* 需署名作者
* 作者不承担代码使用后的任何风险